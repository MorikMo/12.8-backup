# Домашнее задание к занятию «Резервное копирование баз данных» - Фастовец Александр

**Домашнее задание выполните в Google Docs или в md-файле в вашем репозитории GitHub.** 

Для оформления вашего решения в GitHub можете воспользоваться [шаблоном](https://github.com/netology-code/sys-pattern-homework).

Название файла должно содержать номер лекции и фамилию студента. Пример названия: «12.8. Резервное копирование баз данных — Александр Александров».

Перед тем как выслать ссылку, убедитесь, что её содержимое не является приватным, то есть открыто на просмотр всем, у кого есть ссылка. Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Любые вопросы по решению задач задавайте в чате учебной группы.

---

### Задание 1. Резервное копирование

### Кейс
Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования. 

Необходимо описать, какие варианты резервного копирования подходят в случаях: 

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

*Приведите ответ в свободной форме.*

---

### Решение 1 

#### 1.1. Восстановление данных в полном объёме за предыдущий день

Для этого случая оптимально подходит стратегия, сочетающая **ежедневное полное резервное копирование**.

*   **Механизм:** Полная резервная копия всей базы данных создается каждые 24 часа, обычно в период наименьшей нагрузки (например, ночью).
*   **Процесс восстановления:** В случае сбоя для восстановления данных на конец предыдущего дня потребуется только одна последняя полная копия. Процесс простой и быстрый.
*   **Дополнение:** Для экономии места и времени можно использовать схему «полная копия раз в неделю + ежедневные инкрементные/дифференциальные копии». Однако для восстановления на конец дня всё равно потребуется всего два компонента: последняя полная копия и последняя дифференциальная (или цепочка инкрементных копий). **Ежедневное полное копирование — самое простое и надежное решение для данной задачи.**

#### 1.2. Восстановление данных за час до предполагаемой поломки

Это требование подразумевает возможность восстановления на конкретный момент времени (Point-in-Time Recovery, PITR). Наилучшим решением будет стратегия **полного копирования + журнал транзакций**.

*   **Механизм:**
    1.  Регулярное создание полных резервных копий (например, ежедневно).
    2.  **Непрерывное архивирование журнала транзакций** (transaction log backups) с высокой частотой, например, каждые 15-30 минут.
*   **Процесс восстановления:**
    1.  Восстанавливается последняя полная резервная копия.
    2.  На неё последовательно накатываются все архивные журналы транзакций, вплоть до момента за час до сбоя.
*   **Альтернатива (для некоторых систем):** Использование **снимков (snapshots)** томов или дисков, если СУБД и система хранения это поддерживают. Снимки можно создавать ежечасно, что позволит быстро откатиться к состоянию на конкретный час. Однако PITR на основе журналов транзакций является более точным и отраслевым стандартом.

#### 1.3. Моментальное переключение на работающую базу при поломке

Да, такой кейс возможен. Это реализуется не просто резервным копированием, а механизмами **высокой доступности (High Availability, HA)** и **аварийного переключения (Failover)**.

*   **Механизм:** Развертывание **отказоустойчивого кластера баз данных**. Чаще всего используется архитектура с репликацией:
    *   **Primary (Основной) сервер** — обрабатывает всю рабочую нагрузку.
    *   **Secondary (Реплика) сервер** — постоянно синхронизируется с основным.
*   **Типы репликации и их влияние:**
    *   **Синхронная репликация:** Гарантирует, что данные записываются на основной сервер и реплику одновременно.
    *   **Асинхронная репликация:** Данные сначала записываются на основной сервер, а затем реплицируются. Возможна потеря нескольких секунд или десятков секунд данных при сбое.
*   **Процесс переключения (Failover):** При падении основного сервера система автоматически и моментально перенаправляет входящие запросы на рабочую реплику, которая становится новым основным сервером. Пользователи могут заметить лишь кратковременную задержку.

---

## Задание 2. PostgreSQL

2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).

2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?

*Приведите ответ в свободной форме.*

---

### Решение 2.

2.1 Пример команды резервирования данных и восстановления БД. Дополнительные флаги позволят более качественно и быстро восстановить базу. Например удалять имеющиеся значения перед восстановлением (--clean) и использовать парралельное восстановление (-j).
- Резервное копирование:
  - ```pg_dump -h db.example.com -U backup_user -F c -f /backups/mydb.dump mydb```
 
- Восстановление:
  - ```createdb -h db.example.com -U postgres mydb_restored```
  - ```pg_restore -h db.example.com -U postgres -d mydb_restored --clean --if-exists -j 4 /backups/mydb.dump```

2.2 Да, процесс можно автоматизировать, например с помощью cron и shell-скрипта. 

- ~/.pgpass для безопасной аутентификации:
  - ```echo "db.example.com:5432:mydb:backup_user:SuperSecret" >> ~/.pgpass```
  - ```chmod 600 ~/.pgpass```
    
Скрипт /usr/local/bin/pgdump_daily.sh:

```
#!/usr/bin/env bash
set -euo pipefail
DB_HOST="db.example.com"
DB_NAME="mydb"
DB_USER="backup_user"
OUT_DIR="/var/backups/postgres"
TS=$(date +%F_%H%M%S)
mkdir -p "$OUT_DIR"
FILE="$OUT_DIR/${DB_NAME}_${TS}.dump"
pg_dump -h "$DB_HOST" -U "$DB_USER" -F c -f "$FILE" "$DB_NAME"
find "$OUT_DIR" -name "${DB_NAME}_*.dump" -mtime +14 -delete
```
В планировщике cron добавим строку

```
0 2 * * * /usr/local/bin/pgdump_daily.sh >> /var/log/pgdump_daily.log 2>&1
```

### Время выполнения:
- `0 2 * * *` - выполняется **ежедневно в 2:00 ночи**

### Команда:
- `/usr/local/bin/pgdump_daily.sh` - путь к скрипту резервного копирования
- `>> /var/log/pgdump_daily.log` - добавление вывода в лог-файл (append)
- `2>&1` - перенаправление stderr в stdout (логируются и ошибки, и обычный вывод)

## Что это дает:
- **Автоматическое ежедневное резервное копирование** в 2:00
- **Логирование** всех сообщений и ошибок в файл `/var/log/pgdump_daily.log`
- **Ротация бэкапов** - старые бэкапы автоматически удаляются (согласно логике скрипта)

---

---

### Задание 3. MySQL

3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL. 

---

### Решение 3.1

Пример команды создания инкрементной резервной копии:

```bash
mysqlbackup --defaults-file=/home/dbadmin/my.cnf \
  --incremental \
  --incremental-base=history:last_backup \
  --backup-dir=/home/dbadmin/temp_dir \
  --backup-image=incremental_image1.bi \
  backup-to-image
```

**Пояснение ключевых параметров:**

*   `--defaults-file`: Путь к файлу с параметрами подключения к БД (например, `my.cnf`).
*   `--incremental`: Флаг, указывающий на создание инкрементного бэкапа.
*   `--incremental-base=history:last_backup`: Указывает, что за основание следует взять последнюю успешную резервную копию, информацию о которой `mysqlbackup` автоматически находит в служебной таблице `mysql.backup_history`.
*   `--backup-dir`: Временная директория для обработки данных.
*   `--backup-image` и `backup-to-image`: Создают бэкап в виде единого файла-образа (вместо набора файлов).

---



